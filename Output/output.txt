### ONLY_CHANGED_CLASSES ###
Avaliando A LPS.

The directory of the generated products: <  Tool Path + Products  >


clean_products_folder:
     [echo] This is an Ant Task created to clean the generated products folder.

 Two directories have been deleted:  < Tool Path + Products > and < pluginpath + emma + instr >
Walk through this directory and get all files: D:\101Companies\SecondCategory\littleSPLT\src
Walk through this directory and get all files: D:\101Companies\SecondCategory\littleSPLT02\src



		Let's put the products in cache.


Build the SOURCE Feature Model Alloy file:
source Set OF Features: 

SOURCE Features: 

Feature: tree

Feature: littlespl

Feature: logging

SOURCE FM Semantics: pred semanticasource[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] )
 }

 Alloy File has been created. Check it out in < Tool Path + Alloy + Alloy File >


Build the TARGET Feature Model Alloy file:
target Set OF Features: 

TARGET Features: 

Feature: tree

Feature: precedence

Feature: littlespl

Feature: logging

TARGET FM Semantics: pred semanticatarget[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] ) and ( isTrue[precedence] => isTrue[littlespl] )
 }

 Alloy File has been created. Check it out in < Tool Path + Alloy + Alloy File >


Build the EVOLUTION Alloy file:

 Alloy File has been created. Check it out in < Tool Path + Alloy + Alloy File >


		The products are already in cache.




		Let's check if the SPL is well formed.


Build the SOURCE Feature Model Alloy file:
source Set OF Features: 

SOURCE Features: 

Feature: tree

Feature: littlespl

Feature: logging

SOURCE FM Semantics: pred semanticasource[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] )
 }

 Alloy File has been created. Check it out in < Tool Path + Alloy + Alloy File >


Build the TARGET Feature Model Alloy file:
target Set OF Features: 

TARGET Features: 

Feature: tree

Feature: precedence

Feature: littlespl

Feature: logging

TARGET FM Semantics: pred semanticatarget[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] ) and ( isTrue[precedence] => isTrue[littlespl] )
 }

 Alloy File has been created. Check it out in < Tool Path + Alloy + Alloy File >


Build the SOURCE Configuration Knowledge Alloy file:

Class Content:
package org.softlang.company;
import java.util.Observable;

//#if($LOG)
import org.softlang.main.Walker;
#end

public class Employee extends Observable{

	private String name;
	private double salary;
	
	public Employee(String name, double salary) {
		super();
		this.name = name;
		this.salary = salary;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
		//#if($LOG)
		Walker walker = new Walker();
		walker.m();
		setChanged();
 		notifyObservers("salary");
 		#end
	
	}
	@Override
	public String toString() {
		return "Employee [name=" + name + ", salary=" + salary + "]";
	}
}

Parametros para o SOOT -> Classe:Employee path:D:\101Companies\SecondCategory\littleSPLT\src\org\softlang\company

Provided Class: Employee Dependence: org.softlang.main.Walker

Provided Class: Employee Its Dependencies: org.softlang.main.Walker - constant Required: Walker

Provided Class: Employee Dependence: Walker

Provided Class: Employee Its Dependencies: Walker - constant Required: Walker

Provided Class: Employee Dependence: package org.softlang.company;


Class Name: Employee, src\org\softlang\company\Employee.java

 Provided Classes:  [ Employee ] 

 Required Classes:  [ Walker ] 

Class Content:
package org.softlang.features;

import java.util.Observable;
import java.util.Observer;

import org.softlang.company.Employee;

/**
 * Log all changes to salaries of employees.
 * Log them on stdout and count them.
 */
public class Logging implements Observer {
	public void update(Observable o, Object arg) {
		if (o instanceof Employee && arg instanceof String) {
			Employee e = (Employee)o;
			if (((String)arg).equals("salary")) {
				System.out.println("Salary of " + e.getName() + " adjusted to " + e.getSalary());
			}
		}
	}
}

Parametros para o SOOT -> Classe:Logging path:D:\101Companies\SecondCategory\littleSPLT\src\org\softlang\features

Provided Class: Logging Dependence: org.softlang.company.Employee

Provided Class: Logging Its Dependencies: org.softlang.company.Employee - constant Required: Employee

Provided Class: Logging Dependence: Employee

Provided Class: Logging Its Dependencies: Employee - constant Required: Employee

Provided Class: Logging Dependence: package org.softlang.features;


Class Name: Logging, src\org\softlang\features\Logging.java

 Provided Classes:  [ Logging ] 

 Required Classes:  [ Employee ] 

Class Content:
package org.softlang.main;

import org.softlang.company.Employee;
import org.softlang.features.Logging;

public class Main {

	public static void main(String[] args) {
		System.out.println("Main\n");
		Logging log = new Logging();
		Employee employee = new Employee("Jefferson", 10000.0);
		employee.addObserver(log);
		employee.setSalary(20000.0);
	}

}

Parametros para o SOOT -> Classe:Main path:D:\101Companies\SecondCategory\littleSPLT\src\org\softlang\main
D:\101Companies\SecondCategory\littleSPLT\src\org\softlang\main\Main.java:11:
  Semantic Error: can not instantiate Unknown no matching constructor found in Unknown

Provided Class: Main Dependence: Logging

Provided Class: Main Its Dependencies: Logging - constant Required: Logging

Provided Class: Main Dependence: org.softlang.features.Logging

Provided Class: Main Its Dependencies: org.softlang.features.Logging - constant Required: Logging

Provided Class: Main Dependence: org.softlang.company.Employee

Provided Class: Main Its Dependencies: org.softlang.company.Employee - constant Required: Employee

Provided Class: Main Dependence: Employee

Provided Class: Main Its Dependencies: Employee - constant Required: Employee

Provided Class: Main Dependence: package org.softlang.main;


Class Name: Main, src\org\softlang\main\Main.java

 Provided Classes:  [ Main ] 

 Required Classes:  [ Logging ]  [ Employee ] 

Class Content:
package org.softlang.company;
import java.util.Observable;

//#if($LOG)
import org.softlang.main.Walker;
#end

public class Employee extends Observable{

	private String name;
	private double salary;
	
	public Employee(String name, double salary) {
		super();
		this.name = name;
		this.salary = salary;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
		//#if($LOG)
		Walker walker = new Walker();
		walker.m();
		setChanged();
 		notifyObservers("salary");
 		#end
	
	}
	@Override
	public String toString() {
		return "Employee [name=" + name + ", salary=" + salary + "]";
	}
}

Parametros para o SOOT -> Classe:Employee path:D:\101Companies\SecondCategory\littleSPLT\src\org\softlang\company

Provided Class: Employee Dependence: org.softlang.main.Walker

Provided Class: Employee Its Dependencies: org.softlang.main.Walker - constant Required: Walker

Provided Class: Employee Dependence: Walker

Provided Class: Employee Its Dependencies: Walker - constant Required: Walker

Provided Class: Employee Dependence: package org.softlang.company;


Class Name: Employee, src\org\softlang\company\Employee.java

 Provided Classes:  [ Employee ] 

 Required Classes:  [ Walker ] 

Class Content:
package org.softlang.main;

public class Walker {
	public Walker(){
		super();
	}
	public void m(){
		System.out.println("M()");
	}
}

Parametros para o SOOT -> Classe:Walker path:D:\101Companies\SecondCategory\littleSPLT\src\org\softlang\main

Provided Class: Walker Dependence: package org.softlang.main;


Class Name: Walker, src\org\softlang\main\Walker.java

 Provided Classes:  [ Walker ] 

 Required Classes: 

source Configuration Knowledge Items:
Feature Expression: logging
Provided: {Main=src\org\softlang\main\Main.java}
Required: [Logging, Employee]

Feature Expression: logging
Provided: {Walker=src\org\softlang\main\Walker.java}
Required: []

Feature Expression: tree
Provided: {Employee=src\org\softlang\company\Employee.java}
Required: [Walker]

Feature Expression: logging
Provided: {Employee=src\org\softlang\company\Employee.java}
Required: [Walker]

Feature Expression: logging
Provided: {Logging=src\org\softlang\features\Logging.java}
Required: [Employee]


Feature: tree - Files: tree
Feature: logging - Files: LOG
Feature: preprocess - Files: src\org\softlang\company\Employee.java,src\org\softlang\company\Employee.java
Alloy File Content: open default
 pred provided[] { 
( isTrue[logging] => (isTrue[Main]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[tree] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Logging]) )
 }

 pred required[] { 
( isTrue[logging] => (isTrue[Logging] and isTrue[Employee]) )
( isTrue[tree] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Employee]) )
 }

 pred semanticaCK[] { provided[] => required[] }


Correct Set of Features:

Feature: tree

Feature: littlespl

Feature: logging

Including CK Signatures in Correct Set

Signature: Logging

Signature: Main

Signature: tree

Signature: logging

Signature: Walker

Signature: Employee

Correct Ser Filled:

Correct Item: Logging

Correct Item: Main

Correct Item: tree

Correct Item: littlespl

Correct Item: logging

Correct Item: Employee

Correct Item: Walker

Create Alloy CK File:
File Name: D:/documentos/Msc/SE/workspace/ferramentaLPSSM\Alloy\sourceCKAlloy.als
Content: module sourceCKAlloy
open default
 pred provided[] { 
( isTrue[logging] => (isTrue[Main]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[tree] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Logging]) )
 }

 pred required[] { 
( isTrue[logging] => (isTrue[Logging] and isTrue[Employee]) )
( isTrue[tree] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Employee]) )
 }

 pred semanticaCK[] { provided[] => required[] }
one sig Logging, Main, tree, littlespl, logging, Employee, Walker in Bool{}

pred semanticasource[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] )
 }
assert WT {semanticasource[] => semanticaCK[]}
check WT for 2

Build the TARGET Configuration Knowledge Alloy file:

Class Content:
package org.softlang.company;
import java.util.Observable;

//#if($LOG)
import org.softlang.main.Walker;
#end

public class Employee extends Observable{

	private String name;
	private double salary;
	
	public Employee(String name, double salary) {
		super();
		this.name = name;
		this.salary = salary;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
		//#if($LOG || $Precedence)
		Walker walker = new Walker();
		walker.m();
		setChanged();
 		notifyObservers("salary");
 		#end
	
	}
	@Override
	public String toString() {
		return "Employee [name=" + name + ", salary=" + salary + "]";
	}
}

Parametros para o SOOT -> Classe:Employee path:D:\101Companies\SecondCategory\littleSPLT02\src\org\softlang\company

Provided Class: Employee Dependence: org.softlang.main.Walker

Provided Class: Employee Its Dependencies: org.softlang.main.Walker - constant Required: Walker

Provided Class: Employee Dependence: Walker

Provided Class: Employee Its Dependencies: Walker - constant Required: Walker

Provided Class: Employee Dependence: package org.softlang.company;


Class Name: Employee, src\org\softlang\company\Employee.java

 Provided Classes:  [ Employee ] 

 Required Classes:  [ Walker ] 

Class Content:
package org.softlang.features;

import java.util.Observable;
import java.util.Observer;

import org.softlang.company.Employee;

/**
 * Log all changes to salaries of employees.
 * Log them on stdout and count them.
 */
public class Logging implements Observer {
	public void update(Observable o, Object arg) {
		if (o instanceof Employee && arg instanceof String) {
			Employee e = (Employee)o;
			if (((String)arg).equals("salary")) {
				System.out.println("Salary of " + e.getName() + " adjusted to " + e.getSalary());
			}
		}
	}
}

Parametros para o SOOT -> Classe:Logging path:D:\101Companies\SecondCategory\littleSPLT02\src\org\softlang\features

Provided Class: Logging Dependence: org.softlang.company.Employee

Provided Class: Logging Its Dependencies: org.softlang.company.Employee - constant Required: Employee

Provided Class: Logging Dependence: Employee

Provided Class: Logging Its Dependencies: Employee - constant Required: Employee

Provided Class: Logging Dependence: package org.softlang.features;


Class Name: Logging, src\org\softlang\features\Logging.java

 Provided Classes:  [ Logging ] 

 Required Classes:  [ Employee ] 

Class Content:
package org.softlang.main;

import org.softlang.company.Employee;
import org.softlang.features.Logging;

public class Main {

	public static void main(String[] args) {
		System.out.println("Main\n");
		Logging log = new Logging();
		Employee employee = new Employee("Jefferson", 10000.0);
		employee.addObserver(log);
		employee.setSalary(20000.0);
	}

}

Parametros para o SOOT -> Classe:Main path:D:\101Companies\SecondCategory\littleSPLT02\src\org\softlang\main
D:\101Companies\SecondCategory\littleSPLT02\src\org\softlang\main\Main.java:11:
  Semantic Error: can not instantiate Unknown no matching constructor found in Unknown

Provided Class: Main Dependence: Logging

Provided Class: Main Its Dependencies: Logging - constant Required: Logging

Provided Class: Main Dependence: org.softlang.features.Logging

Provided Class: Main Its Dependencies: org.softlang.features.Logging - constant Required: Logging

Provided Class: Main Dependence: org.softlang.company.Employee

Provided Class: Main Its Dependencies: org.softlang.company.Employee - constant Required: Employee

Provided Class: Main Dependence: Employee

Provided Class: Main Its Dependencies: Employee - constant Required: Employee

Provided Class: Main Dependence: package org.softlang.main;


Class Name: Main, src\org\softlang\main\Main.java

 Provided Classes:  [ Main ] 

 Required Classes:  [ Logging ]  [ Employee ] 

Class Content:
package org.softlang.company;
import java.util.Observable;

//#if($LOG)
import org.softlang.main.Walker;
#end

public class Employee extends Observable{

	private String name;
	private double salary;
	
	public Employee(String name, double salary) {
		super();
		this.name = name;
		this.salary = salary;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public double getSalary() {
		return salary;
	}
	public void setSalary(double salary) {
		this.salary = salary;
		//#if($LOG || $Precedence)
		Walker walker = new Walker();
		walker.m();
		setChanged();
 		notifyObservers("salary");
 		#end
	
	}
	@Override
	public String toString() {
		return "Employee [name=" + name + ", salary=" + salary + "]";
	}
}

Parametros para o SOOT -> Classe:Employee path:D:\101Companies\SecondCategory\littleSPLT02\src\org\softlang\company

Provided Class: Employee Dependence: org.softlang.main.Walker

Provided Class: Employee Its Dependencies: org.softlang.main.Walker - constant Required: Walker

Provided Class: Employee Dependence: Walker

Provided Class: Employee Its Dependencies: Walker - constant Required: Walker

Provided Class: Employee Dependence: package org.softlang.company;


Class Name: Employee, src\org\softlang\company\Employee.java

 Provided Classes:  [ Employee ] 

 Required Classes:  [ Walker ] 

Class Content:
package org.softlang.main;

public class Walker {
	public Walker(){
		super();
	}
	public void m(){
		System.out.println("M()");
	}
}

Parametros para o SOOT -> Classe:Walker path:D:\101Companies\SecondCategory\littleSPLT02\src\org\softlang\main

Provided Class: Walker Dependence: package org.softlang.main;


Class Name: Walker, src\org\softlang\main\Walker.java

 Provided Classes:  [ Walker ] 

 Required Classes: 

target Configuration Knowledge Items:
Feature Expression: logging
Provided: {Main=src\org\softlang\main\Main.java}
Required: [Logging, Employee]

Feature Expression: logging
Provided: {Walker=src\org\softlang\main\Walker.java}
Required: []

Feature Expression: tree
Provided: {Employee=src\org\softlang\company\Employee.java}
Required: [Walker]

Feature Expression: logging
Provided: {Employee=src\org\softlang\company\Employee.java}
Required: [Walker]

Feature Expression: logging
Provided: {Logging=src\org\softlang\features\Logging.java}
Required: [Employee]


Feature: precedence - Files: Precedence
Feature: tree - Files: tree
Feature: logging - Files: LOG
Feature: preprocess - Files: src\org\softlang\company\Employee.java,src\org\softlang\company\Employee.java,src\org\softlang\company\Employee.java
Alloy File Content: open default
 pred provided[] { 
( isTrue[logging] => (isTrue[Main]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[tree] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Logging]) )
 }

 pred required[] { 
( isTrue[logging] => (isTrue[Logging] and isTrue[Employee]) )
( isTrue[tree] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Employee]) )
 }

 pred semanticaCK[] { provided[] => required[] }


Correct Set of Features:

Feature: tree

Feature: precedence

Feature: littlespl

Feature: logging

Including CK Signatures in Correct Set

Signature: Logging

Signature: Main

Signature: tree

Signature: logging

Signature: Walker

Signature: Employee

Correct Ser Filled:

Correct Item: Logging

Correct Item: Main

Correct Item: tree

Correct Item: precedence

Correct Item: littlespl

Correct Item: logging

Correct Item: Employee

Correct Item: Walker

Create Alloy CK File:
File Name: D:/documentos/Msc/SE/workspace/ferramentaLPSSM\Alloy\targetCKAlloy.als
Content: module targetCKAlloy
open default
 pred provided[] { 
( isTrue[logging] => (isTrue[Main]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[tree] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Logging]) )
 }

 pred required[] { 
( isTrue[logging] => (isTrue[Logging] and isTrue[Employee]) )
( isTrue[tree] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Employee]) )
 }

 pred semanticaCK[] { provided[] => required[] }
one sig Logging, Main, tree, precedence, littlespl, logging, Employee, Walker in Bool{}

pred semanticatarget[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] ) and ( isTrue[precedence] => isTrue[littlespl] )
 }
assert WT {semanticatarget[] => semanticaCK[]}
check WT for 2


		The beginning of the safe composition test to the source SPL


Features: < 3 >
 [ tree ]  [ littlespl ]  [ logging ] 

Checking CK ... 

FileContent: module sourceCKAlloy
open default
 pred provided[] { 
( isTrue[logging] => (isTrue[Main]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[tree] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Logging]) )
 }

 pred required[] { 
( isTrue[logging] => (isTrue[Logging] and isTrue[Employee]) )
( isTrue[tree] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Employee]) )
 }

 pred semanticaCK[] { provided[] => required[] }
one sig Logging, Main, tree, littlespl, logging, Employee, Walker in Bool{}

pred semanticasource[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] )
 }
assert WT {semanticasource[] => semanticaCK[]}
check WT for 2


Content: module sourceCKAlloy
open default
 pred provided[] { 
( isTrue[logging] => (isTrue[Main]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[tree] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Logging]) )
 }

 pred required[] { 
( isTrue[logging] => (isTrue[Logging] and isTrue[Employee]) )
( isTrue[tree] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Employee]) )
 }

 pred semanticaCK[] { provided[] => required[] }
one sig Logging, Main, tree, littlespl, logging, Employee, Walker in Bool{}

pred semanticasource[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] )
 }
assert WT {semanticasource[] => semanticaCK[]}
check WT for 2

world get All Commands SIZE: 1
Command: Check WT for 2

ans:
 ---INSTANCE---
integers={-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
univ={default/FM$0, default/True$0, default/False$0, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
Int={-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
seq/Int={0, 1}
String={}
none={}
default/FM={default/FM$0}
default/FM<:features={default/FM$0->default/True$0}
default/True={default/True$0}
default/False={default/False$0}
default/Bool={default/True$0, default/False$0}
this/Logging={default/False$0}
this/Main={default/True$0}
this/tree={default/True$0}
this/littlespl={default/True$0}
this/logging={default/False$0}
this/Employee={default/True$0}
this/Walker={default/False$0}


1 -> Feature Name: tree

Result: {default/True$0}
tree = True

2 -> Feature Name: littlespl

Result: {default/True$0}
littlespl = True

3 -> Feature Name: logging

Result: {default/False$0}
logging = False

Feature Assignment:
1 -> tree=True
2 -> littlespl=True
3 -> logging=False
returnn: true -  num: 1
world get All Commands SIZE: 2
Command: Check WT for 2

ans:
 ---INSTANCE---
integers={-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
univ={default/FM$0, default/True$0, default/False$0, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
Int={-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
seq/Int={0, 1}
String={}
none={}
default/FM={default/FM$0}
default/FM<:features={default/FM$0->default/True$0}
default/True={default/True$0}
default/False={default/False$0}
default/Bool={default/True$0, default/False$0}
this/Logging={default/False$0}
this/Main={default/True$0}
this/tree={default/True$0}
this/littlespl={default/True$0}
this/logging={default/False$0}
this/Employee={default/True$0}
this/Walker={default/False$0}


1 -> Feature Name: tree

Result: {default/True$0}
tree = True

2 -> Feature Name: littlespl

Result: {default/True$0}
littlespl = True

3 -> Feature Name: logging

Result: {default/False$0}
logging = False

Feature Assignment:
1 -> tree=True
2 -> littlespl=True
3 -> logging=False
returnn: false -  num: 2
duplicated product: {tree=True, littlespl=True, logging=False}

		End of Safe Composition test to the + source SPL

Well Formedness to the <Source> SPL: false


		The beginning of the safe composition test to the target SPL


Features: < 4 >
 [ tree ]  [ precedence ]  [ littlespl ]  [ logging ] 

Checking CK ... 

FileContent: module targetCKAlloy
open default
 pred provided[] { 
( isTrue[logging] => (isTrue[Main]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[tree] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Logging]) )
 }

 pred required[] { 
( isTrue[logging] => (isTrue[Logging] and isTrue[Employee]) )
( isTrue[tree] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Employee]) )
 }

 pred semanticaCK[] { provided[] => required[] }
one sig Logging, Main, tree, precedence, littlespl, logging, Employee, Walker in Bool{}

pred semanticatarget[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] ) and ( isTrue[precedence] => isTrue[littlespl] )
 }
assert WT {semanticatarget[] => semanticaCK[]}
check WT for 2


Content: module targetCKAlloy
open default
 pred provided[] { 
( isTrue[logging] => (isTrue[Main]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[tree] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Employee]) )
( isTrue[logging] => (isTrue[Logging]) )
 }

 pred required[] { 
( isTrue[logging] => (isTrue[Logging] and isTrue[Employee]) )
( isTrue[tree] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Walker]) )
( isTrue[logging] => (isTrue[Employee]) )
 }

 pred semanticaCK[] { provided[] => required[] }
one sig Logging, Main, tree, precedence, littlespl, logging, Employee, Walker in Bool{}

pred semanticatarget[] { 
isTrue[littlespl] and ( isTrue[tree] <=> isTrue[littlespl] ) and ( isTrue[logging] => isTrue[littlespl] ) and ( isTrue[precedence] => isTrue[littlespl] )
 }
assert WT {semanticatarget[] => semanticaCK[]}
check WT for 2

world get All Commands SIZE: 1
Command: Check WT for 2

ans:
 ---INSTANCE---
integers={-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
univ={default/FM$0, default/True$0, default/False$0, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
Int={-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
seq/Int={0, 1}
String={}
none={}
default/FM={default/FM$0}
default/FM<:features={default/FM$0->default/True$0}
default/True={default/True$0}
default/False={default/False$0}
default/Bool={default/True$0, default/False$0}
this/Logging={default/False$0}
this/Main={default/True$0}
this/tree={default/True$0}
this/precedence={default/True$0}
this/littlespl={default/True$0}
this/logging={default/False$0}
this/Employee={default/True$0}
this/Walker={default/False$0}


1 -> Feature Name: tree

Result: {default/True$0}
tree = True

2 -> Feature Name: precedence

Result: {default/True$0}
precedence = True

3 -> Feature Name: littlespl

Result: {default/True$0}
littlespl = True

4 -> Feature Name: logging

Result: {default/False$0}
logging = False

Feature Assignment:
1 -> precedence=True
2 -> tree=True
3 -> littlespl=True
4 -> logging=False
returnn: true -  num: 1
world get All Commands SIZE: 2
Command: Check WT for 2

ans:
 ---INSTANCE---
integers={-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
univ={default/FM$0, default/True$0, default/False$0, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
Int={-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7}
seq/Int={0, 1}
String={}
none={}
default/FM={default/FM$0}
default/FM<:features={default/FM$0->default/True$0}
default/True={default/True$0}
default/False={default/False$0}
default/Bool={default/True$0, default/False$0}
this/Logging={default/False$0}
this/Main={default/True$0}
this/tree={default/True$0}
this/precedence={default/True$0}
this/littlespl={default/True$0}
this/logging={default/False$0}
this/Employee={default/True$0}
this/Walker={default/False$0}


1 -> Feature Name: tree

Result: {default/True$0}
tree = True

2 -> Feature Name: precedence

Result: {default/True$0}
precedence = True

3 -> Feature Name: littlespl

Result: {default/True$0}
littlespl = True

4 -> Feature Name: logging

Result: {default/False$0}
logging = False

Feature Assignment:
1 -> precedence=True
2 -> tree=True
3 -> littlespl=True
4 -> logging=False
returnn: false -  num: 2
duplicated product: {precedence=True, tree=True, littlespl=True, logging=False}

		End of Safe Composition test to the + target SPL

Well Formedness to the <Target> SPL.: false




		Ok. We have already checked the well formedness.


	 -> WF: false


 Software Product Line Short Report :

- It is NOT a refinement.

- It is NOT well formed.


new directory: D:/documentos/Msc/SE/workspace/ferramentaLPSSM\Resultados\Report-littleSPLT-littleSPLT02

	 SPL REPORT: 

-> Source Product Line is Well Formed:?  false
-> Target Product Line is Well Formed:?  false
-> Asset Mappings are Equals :?false
-> Are Configuration Knowledge and Feature Model a refinement:?  false
-> The evolution has a compatible observable behavior:?  true
-> My Whole Software Product Line is Well Formed:?  false
-> My Whole Software Product Line is a Refinement:?  false



